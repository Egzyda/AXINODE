/* engine.js - ゲームの計算ロジックと状態管理（完全版） */
import { BUILDINGS, TECHNOLOGIES, NATION_TEMPLATES, MAGICS, HERO_TEMPLATES, SPECIALIST_TEMPLATES } from './data.js';

// ------------------------------------------------------------------
// 1. 定数 (Constants)
// ------------------------------------------------------------------
export const CONSTANTS = {
  DAYS_PER_MONTH: 30,
  // 基礎生産量
  BASE_FOOD_PRODUCTION: 2.0,      // 農民1人あたり
  BASE_ORE_PRODUCTION: 0.8,       // 鉱夫1人あたり
  BASE_WEAPON_PRODUCTION: 0.5,    // 職人1人あたり
  BASE_ARMOR_PRODUCTION: 0.3,     // 職人1人あたり
  BASE_MANA_PRODUCTION: 0,        // 魔法塔がないと0
  // 消費量
  BASE_FOOD_CONSUMPTION_CIVILIAN: 0.8,
  BASE_FOOD_CONSUMPTION_SOLDIER: 1.2,
  // 税収
  BASE_TAX_PER_POPULATION: 2.0,
  // 閾値
  SATISFACTION_GROWTH: 70,
  SATISFACTION_DECLINE: 30,
  // ゲーム速度
  GAME_SPEEDS: [1, 2, 5, 10, 20],
  // 初期値
  INITIAL_GOLD: 500,
  INITIAL_FOOD: 150,
  INITIAL_POPULATION: 15,
  // セーブ関連
  SAVE_KEY: 'axinode_save',
  AUTOSAVE_INTERVAL: 60000,
  // 戦闘関連
  SOLDIER_MAINTENANCE: 3,        // 兵士1人の維持費/月
  SOLDIER_COMBAT_POWER: 1.0,     // 兵士1人の基本戦闘力
  // イベント確率
  EVENT_CHECK_INTERVAL: 0.5,     // イベントチェック間隔（日）
};

// ------------------------------------------------------------------
// 2. 計算関数 (Calculations)
// ------------------------------------------------------------------
export const Calcs = {
  // 食糧生産
  foodProduction(state) {
    const base = state.population.farmers * CONSTANTS.BASE_FOOD_PRODUCTION;
    let bonusPercent = 0;

    state.buildings.forEach(b => {
      if (b.effect.type === 'foodProduction') bonusPercent += b.effect.value;
    });

    // 魔法効果
    state.activeEffects.forEach(eff => {
      if (eff.type === 'foodProduction') bonusPercent += eff.value;
    });

    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'farmEfficiency') {
        bonusPercent += t.effect.value;
      }
    });

    // 貿易協定ボーナス
    state.aiNations.forEach(nation => {
      if (nation.treaties.some(t => t.type === 'trade')) {
        bonusPercent += 5;
      }
    });

    // 工業化ボーナス
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'productionBonus') {
        bonusPercent += t.effect.value;
      }
    });

    return base * (1 + bonusPercent / 100);
  },

  // 食糧消費
  foodConsumption(state) {
    const civilians = state.population.total - state.military.totalSoldiers;
    return (civilians * CONSTANTS.BASE_FOOD_CONSUMPTION_CIVILIAN) +
      (state.military.totalSoldiers * CONSTANTS.BASE_FOOD_CONSUMPTION_SOLDIER);
  },

  // 鉱石生産
  oreProduction(state) {
    const base = state.population.miners * CONSTANTS.BASE_ORE_PRODUCTION;
    let bonusPercent = 0;

    state.buildings.forEach(b => {
      if (b.effect.type === 'oreProduction') bonusPercent += b.effect.value;
    });

    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'productionBonus') {
        bonusPercent += t.effect.value;
      }
    });

    return base * (1 + bonusPercent / 100);
  },

  // 武器生産
  weaponProduction(state) {
    const base = state.population.craftsmen * CONSTANTS.BASE_WEAPON_PRODUCTION;
    let bonusPercent = 0;

    state.buildings.forEach(b => {
      if (b.effect.type === 'weaponProduction') bonusPercent += b.effect.value;
    });
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'weaponProduction') {
        bonusPercent += t.effect.value;
      }
    });
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'productionBonus') {
        bonusPercent += t.effect.value;
      }
    });

    return base * (1 + bonusPercent / 100);
  },

  // 鎧生産
  armorProduction(state) {
    const base = state.population.craftsmen * CONSTANTS.BASE_ARMOR_PRODUCTION;
    let bonusPercent = 0;

    state.buildings.forEach(b => {
      if (b.effect.type === 'armorProduction') bonusPercent += b.effect.value;
    });
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'productionBonus') {
        bonusPercent += t.effect.value;
      }
    });

    return base * (1 + bonusPercent / 100);
  },

  // 魔力生産
  manaProduction(state) {
    let mana = 0;

    state.buildings.forEach(b => {
      if (b.effect.type === 'manaGeneration') {
        mana += b.effect.value;
      }
    });

    return mana;
  },

  // 税収 (月次)
  taxIncome(state) {
    const baseTax = state.population.total * CONSTANTS.BASE_TAX_PER_POPULATION;
    const satisfactionCoef = state.satisfaction / 100;
    const taxRate = state.taxRate || 0.15;

    let bonusPercent = 0;
    state.buildings.forEach(b => {
      if (b.effect.type === 'taxBonus' || b.effect.type === 'tradeBonus') {
        bonusPercent += b.effect.value;
      }
    });
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'taxBonus') bonusPercent += t.effect.value;
    });

    return Math.floor(baseTax * satisfactionCoef * taxRate * (1 + bonusPercent / 100));
  },

  // 月次維持費
  maintenance(state) {
    const soldierCost = state.military.totalSoldiers * CONSTANTS.SOLDIER_MAINTENANCE;
    return soldierCost;
  },

  // 満足度計算
  satisfaction(state) {
    let score = 50;

    // 食糧事情
    const consumption = Math.max(1, this.foodConsumption(state));
    const foodDays = state.resources.food / consumption;

    if (foodDays >= 14) score += 25;
    else if (foodDays >= 7) score += 15;
    else if (foodDays >= 3) score += 5;
    else if (foodDays < 1) score -= 30;

    // 税率の影響
    const taxRate = state.taxRate || 0.15;
    if (taxRate > 0.20) score -= 10;
    if (taxRate > 0.25) score -= 10;
    if (taxRate < 0.10) score += 5;

    // 失業率の影響
    const unemploymentRate = state.population.unemployed / Math.max(1, state.population.total);
    if (unemploymentRate > 0.3) score -= 15;
    else if (unemploymentRate > 0.2) score -= 5;

    return Math.max(0, Math.min(100, Math.round(score)));
  },

  // 同時建設可能数
  maxSimultaneousConstruction(state) {
    let max = 1;
    state.technologies.forEach(t => {
      if (t.isResearched && t.effect.type === 'simultaneousConstruction') {
        max = Math.max(max, t.effect.value);
      }
    });
    return max;
  },

  // 研究速度ボーナス
  researchSpeedBonus(state) {
    let bonusPercent = 0;
    state.buildings.forEach(b => {
      if (b.effect.type === 'researchSpeed') bonusPercent += b.effect.value;
    });
    // 魔法効果
    state.activeEffects.forEach(eff => {
      if (eff.type === 'timeAcceleration') bonusPercent += eff.value;
    });
    return 1 + bonusPercent / 100;
  },

  // 建設速度ボーナス
  constructionSpeedBonus(state) {
    let bonusPercent = 0;
    state.activeEffects.forEach(eff => {
      if (eff.type === 'timeAcceleration') bonusPercent += eff.value;
    });
    return 1 + bonusPercent / 100;
  },

  // 装備率計算
  equipmentRate(state) {
    const soldiers = state.military.totalSoldiers;
    if (soldiers === 0) return 100;

    const weapons = state.resources.weapons;
    const armor = state.resources.armor;

    // 武器と鎧の平均装備率
    const weaponRate = Math.min(100, (weapons / soldiers) * 100);
    const armorRate = Math.min(100, (armor / soldiers) * 100);

    return Math.round((weaponRate + armorRate) / 2);
  },

  // 戦闘力計算
  combatPower(state, forDefense = false) {
    const soldiers = state.military.totalSoldiers;
    const equipRate = this.equipmentRate(state) / 100;

    // 装備係数
    let equipCoef = 0.5;
    if (equipRate >= 0.8) equipCoef = 1.0;
    else if (equipRate >= 0.6) equipCoef = 0.85;
    else if (equipRate >= 0.4) equipCoef = 0.7;

    // 士気係数
    const morale = state.military.morale / 100;
    let moraleCoef = 0.65;
    if (morale >= 0.8) moraleCoef = 1.0;
    else if (morale >= 0.6) moraleCoef = 0.85;

    // 技術係数
    let techCoef = 1.0;
    state.technologies.forEach(t => {
      if (t.isResearched) {
        if (t.effect.type === 'archerPower') techCoef += t.effect.value / 100;
        if (t.effect.type === 'siegePower' && !forDefense) techCoef += t.effect.value / 100;
      }
    });

    // 防御時のボーナス
    let defenseBonus = 1.0;
    if (forDefense) {
      state.buildings.forEach(b => {
        if (b.effect.type === 'defense') {
          defenseBonus += b.effect.value / 100;
        }
      });
      // 魔法効果（大結界）
      state.activeEffects.forEach(eff => {
        if (eff.type === 'defenseBonus') defenseBonus += eff.value / 100;
      });
    }

    return Math.floor(soldiers * CONSTANTS.SOLDIER_COMBAT_POWER * equipCoef * moraleCoef * techCoef * defenseBonus);
  }
};

// ------------------------------------------------------------------
// 3. ゲームエンジンクラス (GameEngine)
// ------------------------------------------------------------------
export class GameEngine {
  constructor() {
    this.state = this.createInitialState();
    this.lastTime = 0;
    this.listeners = [];
    this.autosaveTimer = null;
    this.lastEventCheck = 0;
  }

  // 初期状態の作成
  createInitialState() {
    const aiNations = NATION_TEMPLATES.map((template, index) => ({
      id: `nation_${index}`,
      name: template.name,
      personality: template.personality,
      description: template.description,
      population: template.initialPopulation,
      militaryPower: template.initialMilitaryPower,
      economicPower: Math.floor(template.initialPopulation * 1.5),
      techLevel: 1,
      relationWithPlayer: 0,
      treaties: [],
      isAtWar: false,
      aggressiveness: template.aggressiveness,
      expansionDesire: template.expansionDesire,
      lastAttackDay: 0,
    }));

    const initialPop = CONSTANTS.INITIAL_POPULATION;

    return {
      day: 1,
      gameSpeed: 1,
      isPaused: true,
      taxRate: 0.15,
      resources: {
        gold: CONSTANTS.INITIAL_GOLD,
        food: CONSTANTS.INITIAL_FOOD,
        ore: 30,
        mana: 0,
        weapons: 10,
        armor: 5
      },
      population: {
        total: initialPop,
        farmers: Math.floor(initialPop * 0.5),
        miners: Math.floor(initialPop * 0.1),
        craftsmen: Math.floor(initialPop * 0.1),
        soldiers: Math.floor(initialPop * 0.2),
        unemployed: initialPop - Math.floor(initialPop * 0.9)
      },
      satisfaction: 60,
      buildings: [],
      constructionQueue: [],
      technologies: JSON.parse(JSON.stringify(TECHNOLOGIES)),
      researchQueue: [],
      eventLog: [
        { id: 1, type: 'important', message: '新たな国家の歴史が始まりました。', day: 1, time: '1日' }
      ],
      military: {
        totalSoldiers: Math.floor(initialPop * 0.2),
        morale: 70,
        infantry: Math.floor(initialPop * 0.15),
        archers: Math.floor(initialPop * 0.05),
        cavalry: 0
      },
      aiNations: aiNations,
      reputation: 0,
      currentBattle: null,
      gameOver: false,
      gameOverReason: null,
      victory: false,
      victoryType: null,
      bankruptcyDays: 0,
      lowSatisfactionDays: 0,
      conqueredNations: 0,
      activeEffects: [],
      heroes: [],
      specialists: [],
    };
  }

  // 状態更新の購読
  subscribe(callback) {
    this.listeners.push(callback);
  }

  notify() {
    this.listeners.forEach(cb => cb(this.state));
  }

  // --- セーブ/ロード機能 ---
  saveGame() {
    try {
      const saveData = JSON.stringify(this.state);
      localStorage.setItem(CONSTANTS.SAVE_KEY, saveData);
      this.addLog('ゲームをセーブしました', 'domestic');
      return true;
    } catch (e) {
      console.error('セーブに失敗:', e);
      return false;
    }
  }

  loadGame() {
    try {
      const saveData = localStorage.getItem(CONSTANTS.SAVE_KEY);
      if (saveData) {
        const loadedState = JSON.parse(saveData);
        const defaultState = this.createInitialState();
        this.state = this.migrateState(loadedState, defaultState);
        this.addLog('セーブデータをロードしました', 'domestic');
        this.notify();
        return true;
      }
      return false;
    } catch (e) {
      console.error('ロードに失敗:', e);
      return false;
    }
  }

  migrateState(loaded, defaultState) {
    // 必要なプロパティの追加
    const migrations = [
      'resources.armor', 'taxRate', 'military.morale', 'military.infantry',
      'military.archers', 'military.cavalry', 'currentBattle', 'gameOver',
      'gameOverReason', 'victory', 'victoryType', 'bankruptcyDays',
      'gameOverReason', 'victory', 'victoryType', 'bankruptcyDays',
      'lowSatisfactionDays', 'conqueredNations', 'heroes', 'specialists'
    ];

    // リソース
    if (!loaded.resources.armor) loaded.resources.armor = defaultState.resources.armor;
    if (!loaded.taxRate) loaded.taxRate = defaultState.taxRate;

    // 軍事
    if (!loaded.military.morale) loaded.military.morale = defaultState.military.morale;
    if (!loaded.military.infantry) loaded.military.infantry = loaded.military.totalSoldiers;
    if (!loaded.military.archers) loaded.military.archers = 0;
    if (!loaded.military.cavalry) loaded.military.cavalry = 0;

    // ゲーム状態
    if (loaded.currentBattle === undefined) loaded.currentBattle = null;
    if (loaded.gameOver === undefined) loaded.gameOver = false;
    if (loaded.gameOverReason === undefined) loaded.gameOverReason = null;
    if (loaded.victory === undefined) loaded.victory = false;
    if (loaded.victoryType === undefined) loaded.victoryType = null;
    if (loaded.bankruptcyDays === undefined) loaded.bankruptcyDays = 0;
    if (loaded.lowSatisfactionDays === undefined) loaded.lowSatisfactionDays = 0;
    if (loaded.heroes === undefined) loaded.heroes = [];
    if (loaded.specialists === undefined) loaded.specialists = [];
    if (loaded.conqueredNations === undefined) loaded.conqueredNations = 0;

    // AI国家
    if (!loaded.aiNations || loaded.aiNations.length === 0) {
      loaded.aiNations = defaultState.aiNations;
    } else {
      loaded.aiNations.forEach(n => {
        if (n.lastAttackDay === undefined) n.lastAttackDay = 0;
      });
    }

    if (loaded.reputation === undefined) loaded.reputation = 0;
    if (loaded.activeEffects === undefined) loaded.activeEffects = [];

    return loaded;
  }

  deleteSave() {
    try {
      localStorage.removeItem(CONSTANTS.SAVE_KEY);
      return true;
    } catch (e) {
      return false;
    }
  }

  hasSaveData() {
    return localStorage.getItem(CONSTANTS.SAVE_KEY) !== null;
  }

  startAutosave() {
    if (this.autosaveTimer) clearInterval(this.autosaveTimer);
    this.autosaveTimer = setInterval(() => {
      if (!this.state.isPaused && !this.state.gameOver) {
        this.saveGame();
      }
    }, CONSTANTS.AUTOSAVE_INTERVAL);
  }

  stopAutosave() {
    if (this.autosaveTimer) {
      clearInterval(this.autosaveTimer);
      this.autosaveTimer = null;
    }
  }

  // --- ゲームループ ---
  tick(currentTime) {
    if (this.state.isPaused || this.state.gameOver || this.state.victory) {
      this.lastTime = currentTime;
      requestAnimationFrame((t) => this.tick(t));
      return;
    }

    const deltaTime = (currentTime - this.lastTime) / 1000;
    this.lastTime = currentTime;

    const prevDay = Math.floor(this.state.day);
    this.state.day += deltaTime * this.state.gameSpeed * 0.1;
    const currentDay = Math.floor(this.state.day);
    const dayDiff = this.state.day - (prevDay + (this.state.day % 1) - (deltaTime * this.state.gameSpeed * 0.1));
    // ※正確な差分計算が面倒なので、概算でdeltaTimeから計算する方が安全
    const preciseDayProgress = deltaTime * this.state.gameSpeed * 0.1;

    // 持続効果の更新
    this.updateActiveEffects(preciseDayProgress);

    // 日次更新
    if (currentDay > prevDay) {
      this.processDailyUpdate();
      this.checkRandomEvents();
      this.checkAIActions();
    }

    // 月次更新
    if (Math.floor(currentDay / 30) > Math.floor(prevDay / 30)) {
      this.processMonthlyUpdate();
    }

    // 建設・研究の進行
    this.updateProgress(deltaTime * this.state.gameSpeed);

    // AI国家の更新
    this.updateAINations(deltaTime * this.state.gameSpeed);

    // 戦闘の進行
    if (this.state.currentBattle) {
      this.updateBattle(deltaTime * this.state.gameSpeed);
    }

    // 勝敗判定
    this.checkVictoryConditions();
    this.checkDefeatConditions();

    this.notify();
    requestAnimationFrame((t) => this.tick(t));
  }

  startGameLoop() {
    this.lastTime = performance.now();
    requestAnimationFrame((t) => this.tick(t));
  }

  // --- 更新ロジック ---
  processDailyUpdate() {
    // 生産
    const foodProd = Calcs.foodProduction(this.state);
    const oreProd = Calcs.oreProduction(this.state);
    const weaponProd = Calcs.weaponProduction(this.state);
    const armorProd = Calcs.armorProduction(this.state);
    const manaProd = Calcs.manaProduction(this.state);

    // 消費
    const foodCons = Calcs.foodConsumption(this.state);

    // 反映
    this.state.resources.food += (foodProd - foodCons);
    this.state.resources.ore += oreProd;
    this.state.resources.weapons += weaponProd;
    this.state.resources.armor += armorProd;
    this.state.resources.mana += manaProd;

    // 餓死判定
    if (this.state.resources.food < 0) {
      this.state.resources.food = 0;
      const starved = Math.ceil(this.state.population.total * 0.01);
      this.addPopulation(-starved);
      this.addLog(`食糧不足で${starved}人が餓死しました`, 'important');
    }
  }

  processMonthlyUpdate() {
    // 税収と維持費
    const tax = Calcs.taxIncome(this.state);
    const maintenance = Calcs.maintenance(this.state);

    this.state.resources.gold += (tax - maintenance);
    this.addLog(`月次収支: 税収+${tax}G, 維持費-${maintenance}G`, 'domestic');

    // 破産判定
    if (this.state.resources.gold < 0) {
      this.state.bankruptcyDays += 30;
      this.addLog('国庫が破産状態です！', 'important');
    } else {
      this.state.bankruptcyDays = 0;
    }

    // 満足度更新
    this.state.satisfaction = Calcs.satisfaction(this.state);

    // 満足度による判定
    if (this.state.satisfaction <= 0) {
      this.state.lowSatisfactionDays += 30;
    } else {
      this.state.lowSatisfactionDays = 0;
    }

    // 人口増減
    if (this.state.satisfaction >= CONSTANTS.SATISFACTION_GROWTH) {
      const growth = Math.ceil(this.state.population.total * 0.03);
      this.addPopulation(growth);
      this.addLog(`${growth}人の移民が到着しました`, 'domestic');
    } else if (this.state.satisfaction <= CONSTANTS.SATISFACTION_DECLINE) {
      const decline = Math.ceil(this.state.population.total * 0.02);
      this.addPopulation(-decline);
      this.addLog(`${decline}人が国を去りました`, 'important');
    }

    // 貿易協定の期間減少
    this.state.aiNations.forEach(nation => {
      nation.treaties = nation.treaties.filter(t => {
        t.duration -= 1;
        if (t.duration <= 0) {
          this.addLog(`${nation.name}との貿易協定が期限切れになりました`, 'diplomatic');
          return false;
        }
        return true;
      });
    });

    // 士気の自然回復
    if (this.state.military.morale < 70) {
      this.state.military.morale = Math.min(70, this.state.military.morale + 5);
    }
  }

  updateProgress(deltaSeconds) {
    // 建設キューの処理
    const buildSpeed = Calcs.constructionSpeedBonus(this.state);

    for (let i = this.state.constructionQueue.length - 1; i >= 0; i--) {
      this.state.constructionQueue[i].remainingTime -= deltaSeconds * buildSpeed;
      if (this.state.constructionQueue[i].remainingTime <= 0) {
        const completed = this.state.constructionQueue.splice(i, 1)[0];
        const buildingData = BUILDINGS.find(b => b.id === completed.buildingId);

        this.state.buildings.push({ ...buildingData, builtAt: this.state.day });
        this.addLog(`${buildingData.name} の建設が完了しました`, 'domestic');
      }
    }

    // 研究キューの処理
    const speedBonus = Calcs.researchSpeedBonus(this.state);

    for (let i = this.state.researchQueue.length - 1; i >= 0; i--) {
      this.state.researchQueue[i].remainingTime -= deltaSeconds * speedBonus;
      if (this.state.researchQueue[i].remainingTime <= 0) {
        const completed = this.state.researchQueue.splice(i, 1)[0];

        const tech = this.state.technologies.find(t => t.id === completed.techId);
        if (tech) {
          tech.isResearched = true;
          this.addLog(`技術「${tech.name}」の研究が完了しました！`, 'tech');
          this.applyTechEffect(tech);
        }
      }
    }
  }

  applyTechEffect(tech) {
    switch (tech.effect.type) {
      case 'unlockBuilding':
        this.addLog(`新しい施設が建設可能になりました`, 'tech');
        break;
      case 'unlockVictory':
        this.addLog(`技術勝利への道が開かれました！`, 'important');
        break;
      case 'simultaneousConstruction':
        this.addLog(`同時建設可能数が ${tech.effect.value} に増加しました`, 'tech');
        break;
      case 'productionBonus':
        this.addLog(`全体の生産効率が ${tech.effect.value}% 向上しました`, 'tech');
        break;
    }
  }

  updateAINations(deltaSeconds) {
    this.state.aiNations.forEach(nation => {
      if (nation.isDefeated) return;

      // 成長処理
      const dailyGrowth = 1 + (0.005 / 30) * (deltaSeconds / 10);
      nation.population = Math.floor(nation.population * dailyGrowth);
      nation.militaryPower = Math.floor(nation.population * 0.12);
      nation.economicPower = Math.floor(nation.population * 1.5);

      // 関係値の自然変動
      if (nation.relationWithPlayer > 0) {
        nation.relationWithPlayer = Math.max(0, nation.relationWithPlayer - 0.001 * deltaSeconds);
      } else if (nation.relationWithPlayer < 0) {
        nation.relationWithPlayer = Math.min(0, nation.relationWithPlayer + 0.0005 * deltaSeconds);
      }
    });
  }

  // --- ランダムイベント ---
  checkRandomEvents() {
    if (Math.random() > 0.15) return; // 15%の確率でイベント発生

    const events = [
      // ポジティブイベント
      {
        type: 'positive', name: '移住者到着', weight: 20, effect: () => {
          const amount = Math.floor(Math.random() * 10) + 5;
          this.addPopulation(amount);
          this.addLog(`${amount}人の移住者が到着しました！`, 'domestic');
        }
      },
      {
        type: 'positive', name: '豊作', weight: 15, effect: () => {
          const amount = Math.floor(Math.random() * 100) + 50;
          this.state.resources.food += amount;
          this.addLog(`豊作です！食糧+${amount}`, 'domestic');
        }
      },
      {
        type: 'positive', name: '鉱脈発見', weight: 10, effect: () => {
          const amount = Math.floor(Math.random() * 50) + 30;
          this.state.resources.ore += amount;
          this.addLog(`新しい鉱脈が発見されました！鉱石+${amount}`, 'domestic');
        }
      },
      {
        type: 'positive', name: '商人来訪', weight: 15, effect: () => {
          const amount = Math.floor(Math.random() * 100) + 50;
          this.state.resources.gold += amount;
          this.addLog(`大商人が訪れ、取引で${amount}Gを得ました`, 'domestic');
        }
      },
      // 英雄・熟練者イベント
      {
        type: 'positive', name: '英雄来訪', weight: 1, condition: () => this.state.heroes.length < 3 && this.state.reputation >= 20, effect: () => {
          const template = HERO_TEMPLATES[Math.floor(Math.random() * HERO_TEMPLATES.length)];
          // 既にいるかチェック
          if (this.state.heroes.some(h => h.name === template.name)) return;

          this.state.heroes.push({ ...template, joinedAt: this.state.day });
          this.addLog(`英雄「${template.name}」が国に仕えることを申し出ました！`, 'important');
          this.state.military.totalSoldiers += 1; // ユニットとしてカウント
          this.state.reputation += 10;
        }
      },
      {
        type: 'positive', name: '熟練者来訪', weight: 10, effect: () => {
          const template = SPECIALIST_TEMPLATES[Math.floor(Math.random() * SPECIALIST_TEMPLATES.length)];

          this.state.specialists.push({ ...template, joinedAt: this.state.day });
          this.addLog(`熟練者「${template.name}」(${template.type})を雇用しました (給与:${template.salary}G)`, 'domestic');

          // 即時効果があれば適用するが、現状は計算ボーナスのみなので追加だけでOK
        }
      },
      // 外交イベント
      {
        type: 'diplomatic', name: '外交提案', weight: 8, condition: () => this.state.day > 30, effect: () => {
          const target = this.state.aiNations.find(n => !n.isDefeated && n.relationWithPlayer > 0);
          if (target) {
            const gift = Math.floor(Math.random() * 200) + 100;
            this.state.resources.gold += gift;
            this.addLog(`${target.name}から友好の証として${gift}Gが贈られました`, 'diplomatic');
            target.relationWithPlayer += 5;
          }
        }
      },
      // ネガティブイベント
      {
        type: 'negative', name: '干ばつ', weight: 10, condition: () => this.state.day > 15, effect: () => {
          const loss = Math.floor(this.state.resources.food * 0.2);
          this.state.resources.food = Math.max(0, this.state.resources.food - loss);
          this.addLog(`干ばつが発生！食糧-${loss}`, 'important');
        }
      },
      {
        type: 'negative', name: '山賊襲撃', weight: 12, condition: () => this.state.day > 20, effect: () => {
          const goldLoss = Math.floor(this.state.resources.gold * 0.1);
          this.state.resources.gold = Math.max(0, this.state.resources.gold - goldLoss);
          this.addLog(`山賊に襲撃されました！資金-${goldLoss}G`, 'important');
        }
      },
      {
        type: 'negative', name: '疫病', weight: 5, condition: () => this.state.day > 30 && this.state.population.total > 30, effect: () => {
          const loss = Math.ceil(this.state.population.total * 0.05);
          this.addPopulation(-loss);
          this.addLog(`疫病が流行し、${loss}人が亡くなりました`, 'important');
        }
      },
    ];

    // 重み付き抽選
    const availableEvents = events.filter(e => !e.condition || e.condition());
    const totalWeight = availableEvents.reduce((sum, e) => sum + e.weight, 0);
    let random = Math.random() * totalWeight;

    for (const event of availableEvents) {
      random -= event.weight;
      if (random <= 0) {
        event.effect();
        break;
      }
    }
  }

  // --- AI行動 ---
  checkAIActions() {
    if (this.state.currentBattle) return;

    this.state.aiNations.forEach(nation => {
      if (nation.isDefeated || nation.isAtWar) return;
      if (this.state.day < 60) return; // ゲーム開始から60日間は攻撃されない（平和期間）
      if (this.state.day - nation.lastAttackDay < 30) return; // 30日間隔

      // 攻撃判定
      const playerPower = Calcs.combatPower(this.state, true);
      const aggressionRoll = Math.random() * 100;

      if (aggressionRoll < nation.aggressiveness * 0.3) {
        // 弱いと判断したら攻撃
        if (nation.militaryPower > playerPower * 1.2) {
          nation.lastAttackDay = this.state.day;
          this.startBattle(nation.id, true); // 防衛戦
        }
      }
    });
  }

  // --- 戦闘システム ---
  startBattle(nationId, isDefense = false) {
    const nation = this.state.aiNations.find(n => n.id === nationId);
    if (!nation || nation.isDefeated) return { success: false, message: '対象国家が見つかりません' };

    if (this.state.currentBattle) {
      return { success: false, message: '既に戦闘中です' };
    }

    const playerPower = Calcs.combatPower(this.state, isDefense);
    const enemyPower = nation.militaryPower;

    this.state.currentBattle = {
      enemyId: nationId,
      enemyName: nation.name,
      isDefense: isDefense,
      playerForces: {
        initial: this.state.military.totalSoldiers,
        current: this.state.military.totalSoldiers,
        power: playerPower,
        morale: this.state.military.morale
      },
      enemyForces: {
        initial: Math.floor(nation.population * 0.15),
        current: Math.floor(nation.population * 0.15),
        power: enemyPower,
        morale: 70
      },
      elapsed: 0,
      log: [],
      result: null
    };

    const battleType = isDefense ? '防衛戦' : '侵攻戦';
    this.addLog(`${nation.name}との${battleType}が開始されました！`, 'military');
    this.state.currentBattle.log.push(`戦闘開始: 味方${playerPower} vs 敵${enemyPower}`);

    return { success: true };
  }

  updateBattle(deltaSeconds) {
    const battle = this.state.currentBattle;
    if (!battle || battle.result) return;

    battle.elapsed += deltaSeconds;

    // 10秒ごとに戦闘フェーズを処理
    if (battle.elapsed >= 1) {
      battle.elapsed = 0;

      // 戦闘が60秒以上続いた場合、強制的に決着
      if (battle.log.length >= 60) { // logの長さで時間を概算
        if (battle.playerForces.current >= battle.enemyForces.current) {
          this.resolveBattle('victory');
        } else {
          this.resolveBattle('defeat');
        }
        return;
      }

      const playerDamage = Math.floor(battle.enemyForces.power * 0.08);
      const enemyDamage = Math.floor(battle.playerForces.power * 0.10);

      battle.playerForces.current = Math.max(0, battle.playerForces.current - playerDamage);
      battle.enemyForces.current = Math.max(0, battle.enemyForces.current - enemyDamage);

      // 士気変動
      if (battle.playerForces.power > battle.enemyForces.power) {
        battle.playerForces.morale = Math.min(100, battle.playerForces.morale + 2);
        battle.enemyForces.morale = Math.max(0, battle.enemyForces.morale - 3);
      } else {
        battle.playerForces.morale = Math.max(0, battle.playerForces.morale - 3);
        battle.enemyForces.morale = Math.min(100, battle.enemyForces.morale + 2);
      }

      // 戦闘力の再計算（最小値1を保証して無限ループ防止）
      // 兵数が残っているのに戦闘力が0になるとダメージが0になり終わらなくなるため
      battle.playerForces.power = Math.max(1, Math.floor(battle.playerForces.power * (battle.playerForces.current / Math.max(1, battle.playerForces.initial))));
      battle.enemyForces.power = Math.max(1, Math.floor(battle.enemyForces.power * (battle.enemyForces.current / Math.max(1, battle.enemyForces.initial))));

      battle.log.push(`味方: ${battle.playerForces.current}人 (士気${battle.playerForces.morale}%) | 敵: ${battle.enemyForces.current}人`);

      // 勝敗判定
      if (battle.enemyForces.current <= battle.enemyForces.initial * 0.3 || battle.enemyForces.morale <= 20) {
        this.resolveBattle('victory');
      } else if (battle.playerForces.current <= battle.playerForces.initial * 0.3 || battle.playerForces.morale <= 20) {
        this.resolveBattle('defeat');
      }
    }
  }

  resolveBattle(result) {
    const battle = this.state.currentBattle;
    if (!battle) return;

    battle.result = result;
    const nation = this.state.aiNations.find(n => n.id === battle.enemyId);

    if (result === 'victory') {
      const casualties = battle.playerForces.initial - battle.playerForces.current;
      this.state.military.totalSoldiers -= casualties;
      this.state.military.infantry = Math.max(0, this.state.military.infantry - casualties);
      this.state.military.morale = Math.min(100, this.state.military.morale + 10);

      // 戦利品
      const goldSpoils = Math.floor(nation.economicPower * 0.3);
      this.state.resources.gold += goldSpoils;
      this.state.reputation += 5;

      if (!battle.isDefense) {
        // 侵攻勝利で征服
        nation.isDefeated = true;
        this.state.conqueredNations++;
        this.addLog(`${nation.name}を征服しました！戦利品: ${goldSpoils}G`, 'military');
      } else {
        this.addLog(`${nation.name}の侵攻を撃退しました！`, 'military');
        nation.relationWithPlayer -= 20;
      }
    } else {
      const casualties = Math.floor((battle.playerForces.initial - battle.playerForces.current) * 0.8);
      this.state.military.totalSoldiers -= casualties;
      this.state.military.infantry = Math.max(0, this.state.military.infantry - casualties);
      this.state.military.morale = Math.max(20, this.state.military.morale - 15);
      this.state.reputation -= 3;

      if (battle.isDefense) {
        // 防衛失敗でペナルティ
        const goldLoss = Math.floor(this.state.resources.gold * 0.3);
        this.state.resources.gold = Math.max(0, this.state.resources.gold - goldLoss);
        this.addLog(`${nation.name}に敗北しました。${goldLoss}Gを略奪されました`, 'important');
      } else {
        this.addLog(`${nation.name}への侵攻に失敗しました`, 'important');
      }
    }
  }

  closeBattle() {
    this.state.currentBattle = null;
  }

  // --- 勝敗判定 ---
  checkVictoryConditions() {
    // 軍事統一
    const activeNations = this.state.aiNations.filter(n => !n.isDefeated).length;
    if (activeNations === 0) {
      this.state.victory = true;
      this.state.victoryType = 'military';
      this.addLog('全国家を征服しました！軍事統一達成！', 'important');
      return;
    }

    // 技術勝利
    const dimMagic = this.state.technologies.find(t => t.id === 'dimensional_magic');
    if (dimMagic && dimMagic.isResearched && this.state.resources.gold >= 100000) {
      this.state.victory = true;
      this.state.victoryType = 'technology';
      this.addLog('次元門を建設しました！技術勝利達成！', 'important');
      return;
    }

    // 経済勝利
    const allTrade = this.state.aiNations.every(n => n.isDefeated || n.treaties.some(t => t.type === 'trade'));
    if (this.state.resources.gold >= 50000 && allTrade) {
      this.state.victory = true;
      this.state.victoryType = 'economic';
      this.addLog('経済的覇権を達成しました！経済勝利！', 'important');
      return;
    }
  }

  checkDefeatConditions() {
    // 人口0
    if (this.state.population.total <= 0) {
      this.state.gameOver = true;
      this.state.gameOverReason = 'population';
      this.addLog('人口が0になりました。ゲームオーバー...', 'important');
      return;
    }

    // 破産30日
    if (this.state.bankruptcyDays >= 30) {
      this.state.gameOver = true;
      this.state.gameOverReason = 'bankruptcy';
      this.addLog('30日間の破産状態により国家が崩壊しました', 'important');
      return;
    }

    // 満足度0が7日
    if (this.state.lowSatisfactionDays >= 7) {
      this.state.gameOver = true;
      this.state.gameOverReason = 'coup';
      this.addLog('民衆の不満によりクーデターが発生しました', 'important');
      return;
    }
  }

  // --- アクション ---
  togglePause() {
    this.state.isPaused = !this.state.isPaused;
    this.lastTime = performance.now();
    this.notify();
  }

  setSpeed(speed) {
    this.state.gameSpeed = speed;
    this.notify();
  }

  setTaxRate(rate) {
    this.state.taxRate = Math.max(0.05, Math.min(0.30, rate));
    this.notify();
  }

  addPopulation(amount) {
    this.state.population.total = Math.max(0, this.state.population.total + amount);
    if (amount > 0) {
      this.state.population.unemployed += amount;
    } else {
      // 減少時は無職から優先的に減らす
      let remaining = Math.abs(amount);
      const jobs = ['unemployed', 'farmers', 'miners', 'craftsmen'];
      for (const job of jobs) {
        const reduce = Math.min(this.state.population[job], remaining);
        this.state.population[job] -= reduce;
        remaining -= reduce;
        if (remaining <= 0) break;
      }
    }
  }

  // 職業配分
  assignPopulation(job, amount) {
    const currentAssigned = this.state.population.farmers + this.state.population.miners +
      this.state.population.craftsmen + this.state.population.soldiers;
    const maxAssignable = this.state.population.total;

    if (job === 'soldiers') {
      // 兵士への配置は特別処理
      const change = amount - this.state.population.soldiers;
      if (change > 0 && this.state.population.unemployed >= change) {
        this.state.population.soldiers += change;
        this.state.population.unemployed -= change;
        this.state.military.totalSoldiers += change;
        this.state.military.infantry += change;
      } else if (change < 0) {
        const release = Math.min(this.state.population.soldiers, Math.abs(change));
        this.state.population.soldiers -= release;
        this.state.population.unemployed += release;
        this.state.military.totalSoldiers -= release;
        this.state.military.infantry = Math.max(0, this.state.military.infantry - release);
      }
    } else {
      const currentJob = this.state.population[job] || 0;
      const change = amount - currentJob;

      if (change > 0 && this.state.population.unemployed >= change) {
        this.state.population[job] = amount;
        this.state.population.unemployed -= change;
      } else if (change < 0) {
        this.state.population[job] = amount;
        this.state.population.unemployed += Math.abs(change);
      }
    }
    this.notify();
  }

  // 建設開始
  startConstruction(buildingId) {
    const building = BUILDINGS.find(b => b.id === buildingId);
    if (!building) return { success: false, message: '建物が見つかりません' };

    const maxSimultaneous = Calcs.maxSimultaneousConstruction(this.state);
    if (this.state.constructionQueue.length >= maxSimultaneous) {
      return { success: false, message: `同時建設は${maxSimultaneous}件までです` };
    }

    if (this.state.resources.gold < building.cost.gold) {
      return { success: false, message: '資金が不足しています' };
    }
    if (building.cost.ore && this.state.resources.ore < building.cost.ore) {
      return { success: false, message: '鉱石が不足しています' };
    }

    if (building.prerequisite) {
      const hasPrereq = building.prerequisite.every(prereqId => {
        const tech = this.state.technologies.find(t => t.id === prereqId);
        if (tech) return tech.isResearched;
        return this.state.buildings.some(b => b.id === prereqId);
      });
      if (!hasPrereq) {
        return { success: false, message: '前提条件を満たしていません' };
      }
    }

    if (building.maxCount) {
      const currentCount = this.state.buildings.filter(b => b.id === building.id).length;
      if (currentCount >= building.maxCount) {
        return { success: false, message: 'これ以上建設できません' };
      }
    }

    this.state.resources.gold -= building.cost.gold;
    if (building.cost.ore) this.state.resources.ore -= building.cost.ore;

    this.state.constructionQueue.push({
      buildingId: building.id,
      name: building.name,
      remainingTime: building.buildTime / 10
    });

    this.addLog(`${building.name} の建設を開始しました`, 'domestic');
    this.notify();
    return { success: true };
  }

  // 研究開始
  startResearch(techId) {
    const tech = this.state.technologies.find(t => t.id === techId);
    if (!tech) return { success: false, message: '技術が見つかりません' };

    if (tech.isResearched) {
      return { success: false, message: '既に研究済みです' };
    }

    if (this.state.researchQueue.some(r => r.techId === techId)) {
      return { success: false, message: '既に研究中です' };
    }

    if (tech.prerequisite) {
      const hasPrereq = tech.prerequisite.every(prereqId => {
        const prereqTech = this.state.technologies.find(t => t.id === prereqId);
        return prereqTech && prereqTech.isResearched;
      });
      if (!hasPrereq) {
        return { success: false, message: '前提技術を研究していません' };
      }
    }

    if (this.state.resources.gold < tech.cost.gold) {
      return { success: false, message: '資金が不足しています' };
    }
    if (tech.cost.mana && this.state.resources.mana < tech.cost.mana) {
      return { success: false, message: '魔力が不足しています' };
    }

    this.state.resources.gold -= tech.cost.gold;
    if (tech.cost.mana) this.state.resources.mana -= tech.cost.mana;

    this.state.researchQueue.push({
      techId: tech.id,
      name: tech.name,
      remainingTime: tech.researchTime / 10
    });

    this.addLog(`技術「${tech.name}」の研究を開始しました`, 'tech');
    this.notify();
    return { success: true };
  }

  // 貿易協定
  proposeTradeAgreement(nationId) {
    const nation = this.state.aiNations.find(n => n.id === nationId);
    if (!nation) return { success: false, message: '国家が見つかりません' };
    if (nation.isDefeated) return { success: false, message: 'この国家は既に征服されています' };

    if (nation.treaties.some(t => t.type === 'trade')) {
      return { success: false, message: '既に貿易協定を結んでいます' };
    }

    const baseCost = 200;
    const relationModifier = nation.relationWithPlayer < 0 ? 1.5 : 1.0;
    const cost = Math.floor(baseCost * relationModifier);

    if (this.state.resources.gold < cost) {
      return { success: false, message: `資金が不足しています（必要: ${cost}G）` };
    }

    let successChance = 50 + nation.relationWithPlayer / 2;
    if (nation.personality === 'commercial') successChance += 30;
    if (nation.personality === 'aggressive') successChance -= 20;
    if (nation.personality === 'isolationist') successChance -= 40;

    this.state.resources.gold -= cost;

    if (Math.random() * 100 < successChance) {
      nation.treaties.push({ type: 'trade', duration: 12 });
      nation.relationWithPlayer += 10;
      this.addLog(`${nation.name}と貿易協定を締結しました！`, 'diplomatic');
      this.notify();
      return { success: true };
    } else {
      nation.relationWithPlayer -= 5;
      this.addLog(`${nation.name}が貿易協定を拒否しました`, 'diplomatic');
      this.notify();
      return { success: false, message: '提案は拒否されました' };
    }
  }

  // 侵攻開始
  attackNation(nationId) {
    const nation = this.state.aiNations.find(n => n.id === nationId);
    if (!nation) return { success: false, message: '国家が見つかりません' };
    if (nation.isDefeated) return { success: false, message: 'この国家は既に征服されています' };

    if (this.state.military.totalSoldiers < 10) {
      return { success: false, message: '最低10人の兵士が必要です' };
    }

    return this.startBattle(nationId, false);
  }

  // 魔法発動
  castMagic(magicId, targetId = null) {
    const magic = MAGICS.find(m => m.id === magicId);
    if (!magic) return { success: false, message: '魔法が見つかりません' };

    if (this.state.resources.mana < magic.manaCost) {
      return { success: false, message: '魔力が不足しています' };
    }

    // 発動条件チェック
    if (magic.type === 'battle' && !this.state.currentBattle) {
      return { success: false, message: '戦闘中のみ使用可能です' };
    }
    if (magic.type === 'strategic' && !targetId) {
      // 大結界はターゲット不要（自国）だが、天候操作などは必要
      if (magic.id !== 'major_barrier') return { success: false, message: '対象国家を選択してください' };
    }

    // コスト消費
    this.state.resources.mana -= magic.manaCost;

    // 効果適用
    switch (magic.effect.type) {
      case 'foodProduction':
      case 'timeAcceleration':
      case 'defenseBonus':
        if (magic.type === 'domestic' || magic.id === 'major_barrier') {
          // 自国へのバフ
          this.state.activeEffects.push({
            id: magic.id,
            name: magic.name,
            type: magic.effect.type,
            value: magic.effect.value,
            duration: magic.effect.duration,
            maxDuration: magic.effect.duration
          });
          this.addLog(`魔法「${magic.name}」を発動しました！`, 'magic');
        } else {
          // 戦略魔法（敵へのデバフ）未実装部分は簡易ログのみ
          this.addLog(`魔法「${magic.name}」を発動しましたが、対象への効果は未実装です`, 'magic');
        }
        break;

      case 'resourceGain':
        this.state.resources[magic.effect.resource] += magic.effect.value;
        this.addLog(`魔法「${magic.name}」により${magic.effect.value}の${magic.effect.resource}を得ました`, 'magic');
        break;

      case 'directDamage':
        if (this.state.currentBattle) {
          let damage = magic.effect.value;
          // 攻城ボーナスなどがここに入る可能性あり

          this.state.currentBattle.enemyForces.current = Math.max(0, this.state.currentBattle.enemyForces.current - damage);
          this.state.currentBattle.log.push(`魔法攻撃！ 敵軍に${damage}のダメージ！`);
          this.addLog(`魔法「${magic.name}」で敵軍にダメージを与えました`, 'magic');
        }
        break;

      case 'sabotageFood':
      case 'sabotagePopulation':
        if (targetId) {
          const target = this.state.aiNations.find(n => n.id === targetId);
          if (target) {
            if (magic.effect.type === 'sabotagePopulation') {
              const loss = Math.floor(target.population * (magic.effect.value / 100));
              target.population -= loss;
              target.militaryPower = Math.floor(target.population * 0.12); // 戦力も減衰
              this.addLog(`魔法「${magic.name}」が${target.name}の人口を${loss}人減少させました`, 'magic');
              target.relationWithPlayer -= 30;
            } else {
              // 食糧サボタージュなどはAIの成長を阻害する形などで表現
              this.addLog(`魔法「${magic.name}」を${target.name}に発動しました（AIへの効果は限定的です）`, 'magic');
              target.relationWithPlayer -= 20;
            }
          }
        }
        break;
    }

    this.notify();
    return { success: true };
  }

  updateActiveEffects(dayProgress) {
    if (this.state.activeEffects.length === 0) return;

    this.state.activeEffects = this.state.activeEffects.filter(eff => {
      eff.duration -= dayProgress;
      if (eff.duration <= 0) {
        this.addLog(`魔法「${eff.name}」の効果が切れました`, 'domestic');
        return false;
      }
      return true;
    });
  }

  // ログ追加
  addLog(message, type = 'domestic') {
    const time = `${Math.floor(this.state.day)}日`;
    this.state.eventLog.unshift({
      id: Date.now(),
      type,
      message,
      time,
      priority: type === 'important' ? 'high' : 'normal'
    });
    if (this.state.eventLog.length > 50) this.state.eventLog.pop();
  }

  // ニューゲーム
  newGame() {
    this.state = this.createInitialState();
    this.addLog('新しいゲームを開始しました', 'important');
    this.notify();
  }
}
